Whenever a new sub class is added, castToSubclass function of ComponentClass and 
writeModuleInstantiation of GraphToVerilog class have to integrate that calss as well. 
When the added class is of type OPERATOR, additional entity names for each Operator need to be added in entity_names header file

Whenever a new subclass which has to have io ports in top module port list is added, that sub class needs to have 
getModuleIODeclaration in its subclass. Additionally it also needs to have port_din/port_dout, port_valid and port_ready 
in its class members. writeTopModulePorts and generateTopModulePortComponents in the GraphToVerilog also have to integrate these components


tFIFO:
	it uses mod operations with depths that are not powers of 2. This will lead to high utilization.

Start:
	1 Input and 1 Output
	Internally it is pretty much an Elastic Buffer with a few additional controls
	It probably acts as a unit for capturing only one input data for an entire process
	
Sink:
	1 Input and no Output.
	It only sends a HIGH ready_in signal to its previous component. 
	It will do nothing with the source data. 
	
Fork:
	1 Input N Outputs
	
Source:
	same as Sink, but here all Valid_out are 1
	
Const:
	1 input 1 output
	Preceded by a Source.
	Outputs a Constant number specified in its parameters
	
Control Merge:
	N inputs and 2 Outputs
	Out of these N inputs, only the last two(1, 0) are processed.
	The outputs are {condition, data_out}. Both condition and data_out are 1 bit wide.
	

Add/Sub:
	Add will always have only 2 inputs and 1 output as per the vhd file.
	Add uses join internally to make sure that it has both the operands ready before adding.
	So for implementing And, Join has to be implemented.
	
Ret:
	1 input and 1 output always
	Internally, it is exactly same as TEHB
	
TEHB:
	N inputs 1 output, but buffers only the 0th input
	
OEHB:
	N inputs 1 output, but buffers only the 0th input
	
Elastic Buffer:
	1 input and 1 output
	It cascades a TEHB followed by an OEHB
	
End:
	End can have multiple inputs but only one output.
	End also takes the valid and ready of all the memory components(if any).
	The working of end is such that the inputs to end are a list of data input ports and
	memory inputs. The end outputs a single data. That data is one of the input data provided in inputs.
	At the core of this end component is a join component which waits for all memory components to send a valid
	signal and any one of the inputs to end to become valid. As soon as all the memory are valid and any one of
	the input signals are valid, the end component sends that valid input signal to its output and makes its
	valid signal 1.
	*e in input ports of dot file refers to memory inputs
	
	
	
	
	
Potential Tweaks:
1. Improvement in FIFO architecture. It can be designed such that it does not require mod operator
2. Improve the speed of LSQ Generation.
3. Fixed Point arithmetic can dramatically improve utilization + performance and open
	new horizons for memory distributions
4. Division and Remainder support (Added urem support, but weakly implemented in Verilog)
5. Generation of initialized memory with initial values, similar to what generated by Xilinx Block RAM IP
6. GetElementPointer can be a problem in high speed designs. It is meant to do MAC operation combinatorially
	This will lead to larger clock period and the clock period will increase as the dimension increases!
	I verified it on Vivado and modifying Getelementpointer to take 4 clock cycles to calculate the index,
	the clock frequency can be increased from 66MHz to 90MHz.
7. Add and Sub operation will also get into critical path. So we need to add registers to it and after that 
	we can run the design at 125MHz. To do that I placed 3 Buffers in the ADD and SUB operations. 2 at inputs and 1 at output.
	I confirmed the simulation with matrix regression_test and I observed that adding buffers to add/sub leads to 2.5 times
	more clock cycles as compared to without buffers. So we need to make the choice based on our requirement!
8. FIFO also comes into critical path if the depth is not a power of 2.
9. We can create a file for delays of various combinatorial circuits and pass it to the dot parser and the parser can
	accordingly do the buffer placement for creating a design that can be run with the required clock period.
10. Ask about handshake of Join and Buffer
11. Sequential Memory Access of multidimensional arrays can be implemented using adders instead of getelementpointer


Doubtful Components:
	1. Getelementpointer: doubtful about signed or unsigned inputs
	
Assumptions:
	1. All start and end components will have IO ports in top module
	2. Except for Store, MC and LSQ, no two components will have more than one input output connection with eachother.
		This assumption was found wrong in mul_example. There two outputs of fork were connected to mul. Port orderings were not explicit.












