Whenever a new sub class is added, castToSubclass function of ComponentClass and 
writeModuleInstantiation of GraphToVerilog class have to integrate that calss as well. 
When the added class is of type OPERATOR, additional entity names for each Operator need to be added in entity_names header file

Whenever a new subclass which has to have io ports in top module port list is added, that sub class needs to have 
getModuleIODeclaration in its subclass. Additionally it also needs to have port_din/port_dout, port_valid and port_ready 
in its class members. writeTopModulePorts and generateTopModulePortComponents in the GraphToVerilog also have to integrate these components


tFIFO:
	it uses mod operations with depths that are not powers of 2. This will lead to high utilization.

Start:
	1 Input and 1 Output
	Internally it is pretty much an Elastic Buffer with a few additional controls
	It probably acts as a unit for capturing only one input data for an entire process
	
Sink:
	1 Input and no Output.
	It only sends a HIGH ready_in signal to its previous component. 
	It will do nothing with the source data. 
	
Fork:
	1 Input N Outputs
	
Source:
	same as Sink, but here all Valid_out are 1
	
Const:
	1 input 1 output
	Preceded by a Source.
	Outputs a Constant number specified in its parameters
	
Control Merge:
	N inputs and 2 Outputs
	Out of these N inputs, only the last two(1, 0) are processed.
	The outputs are {condition, data_out}. Both condition and data_out are 1 bit wide.
	

Add/Sub:
	Add will always have only 2 inputs and 1 output as per the vhd file.
	Add uses join internally to make sure that it has both the operands ready before adding.
	So for implementing And, Join has to be implemented.
	
Ret:
	1 input and 1 output always
	Internally, it is exactly same as TEHB
	
TEHB:
	N inputs 1 output, but buffers only the 0th input
	
OEHB:
	N inputs 1 output, but buffers only the 0th input
	
Elastic Buffer:
	1 input and 1 output
	It cascades a TEHB followed by an OEHB
	
End:
	End can have multiple inputs but only one output.
	End also takes the valid and ready of all the memory components(if any).
	The working of end is such that the inputs to end are a list of data input ports and
	memory inputs. The end outputs a single data. That data is one of the input data provided in inputs.
	At the core of this end component is a join component which waits for all memory components to send a valid
	signal and any one of the inputs to end to become valid. As soon as all the memory are valid and any one of
	the input signals are valid, the end component sends that valid input signal to its output and makes its
	valid signal 1.
	*e in input ports of dot file refers to memory inputs

Since verilog does not support passing of arrays as arguments, so the program will be written such that
there will be an Input Bus for input to a component and an Output Bus for output from a component.
The Input and Output bus will pack all the ports that are are connected to the input and output side of a component.
Eg.
if input has following ports:
	data_in[0], valid_in[0], ready_in[0]
	data_in[1], valid_in[1], ready_in[1]
	data_in[2], valid_in[2], ready_in[2]
	
then the input port will have the following input buses:
	data_in_bus -> {data_in[2], data_in[1], data_in[0]}
	valid_in_bus -> {valid_in[2], valid_in[1], valid_in[0]}
	ready_in_bus -> {ready_in[2], ready_in[1], ready_in[0]}
	
Similarly output buses will be created